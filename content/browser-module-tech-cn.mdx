---
title: '📦 在浏览器中组织 Web 模块的方式'
publishedAt: '2024-10-15'
summary: "我们将在一篇文章中比较几种模块组织技术，并提供在您的上下文中选择解决问题的正确方法的见解，特别是关注微前端或微模块的加载、解析和运行。"
tags: ['前端', '最佳实践', 'cn']
---

# 📦 在浏览器中组织 Web 模块的方式

> 没有银弹，但要用对工具做对事。

## 简介

在本文中，我们将比较几种模块组织技术，并提供在您的上下文中选择解决问题的正确方法的见解，特别是关注 `微前端` 或 `微模块` 的加载、解析和运行。

一般来说，有几种主流的方式在浏览器中组织模块：

- `npm` - 包和库级别。**NPM** 是一个 JavaScript 包管理器，允许开发人员轻松安装、共享和管理项目中的依赖项，促进 Web 模块的组织，并在不同应用程序之间推广代码重用。
- `umd` - 远程包加载。**UMD** 是一种通用模块定义，允许脚本在各种环境中加载，实现与 CommonJS 和 AMD 模块系统以及浏览器中的全局变量的兼容性。
- `esm` - 在浏览器中导入。**ESM** 是一种现代的 JavaScript 模块系统，允许开发人员在浏览器中直接使用 `import` 和 `export` 语法，实现更清晰和更高效的代码组织。
- `module-federation` - `webpack` 驱动。**MF** 是一种强大的技术，允许多个 Web 应用程序在运行时动态共享和加载代码，在构建现代 Web 架构时提供更大的灵活性和可扩展性。

我们将比较在浏览器中组织 Web 模块的不同技术，突出它们的独特功能、优点和理想的使用场景，以帮助开发人员做出明智的决策。

## 特性 / 优点 / 缺点比较

使用以下技术实现 `微前端` 模式：

| 维度 / 方法 | NPM | UMD | ESM | MF (模块联邦) |
| --- | --- | --- | --- | --- |
| 代码分割策略 | ✅ 支持通过 `Webpack` 或 Rollup 等工具进行代码分割。 | 😈 支持有限；通常会将所有内容打包在一起。 | ✅ 支持动态导入进行代码分割。 | ✨ 在运行时对动态代码分割有出色的支持。 |
| 跨项目代码共享机制 | ✅ 允许通过 npm 注册表在项目之间共享包。 | 😈 可以在项目之间共享脚本，但需要手动管理。 | ✅ 可以通过导入共享模块，但仅限于同源。 | ✨ 内置支持在不同应用之间共享模块。 |
| 低级依赖管理（例如，共享 `react` / `lodash`） | ✅ 通过 [package.json](vscode-file://vscode-app/Applications/Visual%20Studio%20Code.app/Contents/Resources/app/out/vs/code/electron-sandbox/workbench/workbench.esm.html) 管理依赖项；可以共享版本。 | 🤡 没有内置的依赖管理；依赖于全局作用域。 | ✅ 支持导入/导出，但必须手动管理依赖项。 | ✨ 自动共享依赖并\*\*&lt;u&gt;在运行时解决冲突&lt;/u&gt;\*\*。 |
| 代码缓存级别 | ✅ 本地缓存已安装的包；可以在项目之间共享。 | 🤡 没有缓存；每次加载脚本都是新的，除非被浏览器缓存。 | ✅ 在浏览器中缓存模块，提高后续请求的加载时间。 | ✨ 缓存共享模块，减少共享依赖的加载时间。 |
| 类型系统 (`*.d.ts`) | ✅ 通过 DefinitelyTyped 或本地 `.d.ts` 文件支持 TypeScript 定义。 | 🤡 没有内置类型支持；依赖于全局变量类型。 | ✅ 原生支持 TypeScript 通过模块导入。 | 😈 可以与 TypeScript 一起使用，但必须手动管理类型定义。 |
| 加载机制 | ✅ 需要一个构建步骤（例如 Webpack）来打包模块。 | 🤩🤩 直接在浏览器中加载脚本；不需要构建步骤。 | ✅ 现代浏览器原生支持；不需要构建步骤。 | 😈 需要 Webpack 5 或类似工具来设置模块联邦。 |
| 项目设置 | 😈 需要配置 [package.json](vscode-file://vscode-app/Applications/Visual%20Studio%20Code.app/Contents/Resources/app/out/vs/code/electron-sandbox/workbench/workbench.esm.html) 和构建工具。 | 🤩🤩 简单设置；只需在 HTML 中包含脚本。 | ✅ 需要为旧浏览器设置模块打包器；在现代环境中很简单。 | 😈 需要 Webpack 配置，但允许灵活的微前端架构。 |
| **社区支持和生态系统** | ✅ 大量的包生态系统和活跃的社区。 | 😈 支持适中；有许多现有脚本，但开发不活跃。 | ✅ 强大的社区支持，有许多可用资源。 | ✨ 社区正在增长，特别是在微前端爱好者中。 |
| **学习曲线** | 😈 中等；需要熟悉 npm 和包管理。 | 🤩🤩 低；容易包含脚本，无需复杂设置。 | 😈 中等；需要理解模块语法和打包。 | 🤡 **陡峭**；需要理解 Webpack 和微前端概念。 |
| **与其他工具的集成** | ✅ 与各种工具和框架的集成非常好。 | ✅ 与现有脚本和库的集成良好。 | ✅ 与现代框架（如 React、Angular、Vue）的集成强大。 | ✨ 与微前端框架和工具的集成非常好。 |
| **错误处理和调试** | ✅ 标准错误处理；依赖于包管理工具。 | 🤡 基本错误处理；依赖于浏览器控制台。 | ✅ 通过模块导入进行良好的错误处理；更好的调试支持。 | ✨ 高级错误处理；支持运行时错误解决。 |
| **版本控制和兼容性** | ✅ 通过 npm 进行强大的版本控制；很好地处理冲突。 | 🤡 手动版本管理；可能会发生冲突。 | 🤡 手动管理；可能导致兼容性问题。 | ✨ 自动版本解决；在运行时处理冲突。 |
| **性能指标** | ✅ 一般性能良好；取决于包的大小。 | 🤡 性能可能会有所不同；没有内置优化。 | ✅ 通过原生模块加载性能良好；支持优化。 | ✨ 性能出色；允许共享缓存和优化。 |
| **安全考虑** | ✅ 通过 npm 管理安全性；定期更新。 | 🤡 可能发生全局变量冲突；需要手动管理。 | ✅ 支持现代安全实践；依赖于模块导入。 | ✨ 强大的安全功能；在运行时解决冲突。 |
| **部署复杂性** | 😈 中等复杂性；需要构建和部署管道。 | 🤩🤩 低复杂性；容易在 HTML 中包含脚本。 | 😈 中等复杂性；需要设置打包器。 | 🤡 高复杂性；需要 Webpack 配置和微前端设置。 |
| **可扩展性** | ✅ 随项目规模良好扩展；适合较大的应用程序。 | 🤡 可扩展性有限；最适合较小的项目。 | ✅ 良好扩展；适合现代应用程序。 | ✨ 出色的可扩展性；为多个团队的大型应用程序设计。 |
| **对 SSR（服务器端渲染）的支持** | 😈 支持有限；主要集中在客户端。 | 🤡 不适合 SSR；仅限客户端。 | ✅ 通过额外设置支持 SSR；适合 SEO。 | ✨ 对 SSR 的强大支持；适合性能关键的应用程序。 |

## 场景权衡

### **1. 小型到中型项目**

- **推荐技术:** **NPM**
- **权衡:**
  - **优点:** 易于设置和管理依赖关系；拥有大量可用的包生态系统；适用于代码重用至关重要的项目。
  - **缺点:** 需要构建步骤；对动态导入的支持有限；如果管理不当，可能导致较大的包大小。

### **2. 旧版应用程序**

- **推荐技术:** **UMD**
- **权衡:**
  - **优点:** 允许从旧系统逐步迁移；可以在各种环境中工作（CommonJS、AMD、全局变量）；易于与现有脚本集成。
  - **缺点:** 手动管理依赖关系；没有内置缓存；可能不如现代开发实践有效。

### **3. 现代 Web 应用程序**

- **推荐技术:** **ESM**
- **权衡:**
  - **优点:** 现代浏览器中的原生支持；使用 `import` 和 `export` 语法更简洁；支持动态导入以提高性能。
  - **缺点:** 对旧版浏览器的支持有限；需要构建步骤以实现兼容性；依赖关系必须手动管理。

### **4. 多团队的大型应用程序**

- **推荐技术:** **模块联邦 (MF)**
- **权衡:**
  - **优点:** 非常适合微前端架构；允许在运行时动态共享模块；自动依赖解析；促进团队的独立部署。
  - **缺点:** 需要使用 Webpack 进行更复杂的设置；可能在管理共享依赖关系时引入开销；对于不熟悉该技术的团队有学习曲线。

### **5. 快速原型设计**

- **推荐技术:** **UMD 或 NPM**
- **权衡:**
  - **优点:** 快速设置和迭代；UMD 允许无需构建步骤即可轻松包含脚本；NPM 提供访问大量包库的途径。
  - **缺点:** UMD 可能导致依赖冲突；NPM 需要构建过程，这可能会减慢快速迭代的速度。

### **6. 性能关键型应用程序**

- **推荐技术:** **ESM 或 MF**
- **权衡:**
  - **优点:** ESM 支持代码拆分和动态导入，从而提高加载时间；MF 允许共享模块的缓存，减少共享依赖的加载时间。
  - **缺点:** ESM 需要现代浏览器支持；MF 设置可能很复杂，需要彻底测试以确保性能优化有效。

### **7. 跨域应用程序**

- **推荐技术:** **模块联邦 (MF)**
- **权衡:**
  - **优点:** 内置支持跨不同应用程序共享模块，即使它们托管在不同域上；在运行时解决冲突。
  - **缺点:** 设置和配置复杂；需要对 `Webpack` 和微前端原则有扎实的理解。

### **结论**

选择适合组织 Web 模块的技术取决于项目的具体需求和限制。团队规模、项目规模、性能要求和现有技术栈等因素都应影响您的决策。通过了解每种技术的权衡，您可以做出符合项目目标的明智选择，并提高整体开发效率。