---
title: 'ğŸ§­ Spec-Kit + Spec-Driven Design (SDD) â€” Simple BP Guide'
publishedAt: '2026-02-26'
summary: 'A simple guide to Spec-Kit + Spec-Driven Design (SDD) for spec-driven development.'
tags: ['Spec-Kit', 'Spec-Driven', 'Design', 'BP', 'en']
---

## Spec-Kit + Spec-Driven Design (SDD) â€” Simple BP Guide ğŸ§­

### 0) What itâ€™s for (1 sentence)

Use Spec-kit + SDD to make AI-assisted development **reliable and maintainable** by turning â€œchat contextâ€ into **versioned, reviewable artifacts** (spec/plan/tasks) stored in Git. ğŸ§ â¡ï¸ğŸ“

---

## 1) When to use it âœ… / when to skip it âŒ

### Use it when âœ…

* A feature will live **> 3 months** or has non-trivial business rules
* Multiple contributors (or future-you) need to understand â€œwhyâ€
* Youâ€™ve seen AI break existing behavior while adding new features
* The work needs architecture boundaries (modules, aggregates, invariants)

### Skip (or lighten) when âŒ

* Quick demos, throwaway scripts, â€œone-night hackâ€
* Tiny bugfix / UI tweak (â€œ5-minute changeâ€)
* Pure CRUD/static pages with little domain logic

**Rule of thumb:** Spec-kit is a **heavy tool**â€”use it for **complexity**, not ceremony. âš–ï¸

---

## 2) Core idea (the mental model) ğŸ§©

AI has:

* **Limited session memory**
* **High variance output**
* **Risky refactors across unrelated files**

Spec-kit adds:

* **Context anchors**: `spec.md`, `plan.md` (stable, re-usable)
* **Constraints**: `constitution.md` (non-negotiable principles)
* **Isolation**: one feature = one folder (and usually one branch)

---

## 3) Minimal workflow (Spec â†’ Plan â†’ Tasks â†’ Code) ğŸ—ï¸

### Step A â€” Create a feature â€œroomâ€

* Run `/speckit.specify "<Feature Title>"`
* It creates a `specs/<id-or-name>/` directory (and commonly a branch)

### Step B â€” Write `spec.md` (the â€œcontractâ€)

Keep it short but specific:

* Problem & goals
* Non-goals
* Requirements (functional + non-functional)
* Domain model vocabulary (entities, aggregates, invariants)
* Edge cases (the top 10 â€œways this breaksâ€)

### Step C â€” Write `plan.md` (the â€œblueprintâ€)

* Architecture choices (APIs, storage, boundaries)
* File/module touch list (what will change, what must not)
* Migration strategy (if needed)
* Testing approach
* **Constitution check** (explicitly state compliance)

### Step D â€” Write `tasks.md` (the â€œexecution checklistâ€)

* Small, verifiable steps
* Each task produces a diff you can review
* Include tests + rollout steps

### Step E â€” Implement + review

* Code generation/edits should follow tasks
* Human reviews: architecture boundary + requirements coverage
* Merge when spec/plan and code align

---

## 4) â€œConstitutionâ€ (project-wide guardrails) ğŸ›ï¸

Use `.specify/memory/constitution.md` as hard rules, e.g.:

* Layering rules (Service cannot call DB directly)
* Error handling conventions
* Logging & observability requirements
* Security constraints (authn/authz, secrets, encryption)
* Performance budgets (latency, caching requirements)

**Treat it like law:** if constitution changes, itâ€™s an â€œarchitecture change event,â€ not a casual edit. âš ï¸

---

## 5) Preventing the common failures (quick playbook) ğŸ§¯

### Failure: â€œDocs drift / wolf-cryâ€ ğŸ“‰

Fix:

* Run `/speckit.analyze` regularly (audit spec/plan vs code)
* When code changes faster than docs: **reverse-update docs using AI**
* If a spec is dead: mark it `[DEPRECATED]` or create `*-v2` instead of patching forever

### Failure: â€œAI breaks old features when adding new onesâ€ ğŸ’¥

Fix:

* Keep features physically isolated (folder + branch)
* In plan, list **protected files** / â€œdo-not-touch zonesâ€
* Use small tasks with narrow diffs (reduce blast radius)

### Failure: â€œToo much process for small workâ€ ğŸŒ

Fix:

* Establish a â€œå…æ­»é‡‘ç‰Œâ€ policy:

  * small fix â†’ normal PR
  * complex feature â†’ Spec-kit flow

---

## 6) Brownfield adoption (existing legacy project) ğŸšï¸â¡ï¸ğŸ 

Pick one:

1. **Forward-only (recommended)**

* Donâ€™t backfill old code
* Start using Spec-kit for **new complex features**

2. **Crown jewel backfill**

* Only reverse-spec the modules you repeatedly touch
* Generate a spec from code using AI (no refactor required)

3. **Baseline snapshot (rare)**

* Create `000-initial-baseline` with high-level architecture only
* Useful before major refactors or compliance audits

---

## 7) Handling big changes (feature v2 vs edit in place) ğŸ”

Prefer **new spec folder** when changes are meaningful:

* `specs/001-oauth/` (v1)
* `specs/008-oauth-pkce-support/` (increment)
* `specs/015-oauth-ui-redesign/` (major change)

Edit-in-place only for:

* typos
* truly minor adjustments
* clarifications that donâ€™t rewrite history

**Principle:** specs are closer to an **immutable ledger** than a wiki. ğŸ“œ

---

## 8) Parallel development (multi-threading) ğŸ§µ

* Feature A = its own branch + spec folder
* Feature B = separate branch + spec folder
* Before switching: **commit WIP** (save state), then switch

If B depends on A:

* Define contracts early (interfaces)
* In Bâ€™s plan: declare dependency on A
* Optionally branch B off A if needed

---

## 9) Naming strategy (keep it simple) ğŸ·ï¸

Two safe patterns:

### Conservative (max compatibility)

* `001-JIRA-1234-short-name`
* Keeps numeric prefix tooling happy

### Custom (more invasive)

* `dev-JIRA-1234-short-name`
* Requires updating scripts that assume `^[0-9]{3}-`

**Recommendation:** start conservative; go custom only if youâ€™ll maintain the tooling long-term.

---

## 10) â€œGood enoughâ€ templates (copy mental structure) ğŸ§¾

### spec.md (minimum)

* Goal
* Scope / Non-goals
* Requirements (must/should)
* Domain terms
* Edge cases

### plan.md (minimum)

* Architecture approach
* Impacted files/modules
* Data + API changes
* Testing plan
* Constitution check

### tasks.md (minimum)

* Task list (each with expected diff + tests)
